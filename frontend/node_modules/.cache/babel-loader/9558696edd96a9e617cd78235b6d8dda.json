{"ast":null,"code":"// Node\nimport io from 'socket.io-client'; // Own modules\n\nimport { getStore } from '../store';\nimport { SocketIoActions, ChatActions } from '../store/GlobalActions'; // Create socket\n\nexport const socket = io(process.env.REACT_APP_CHAT_URL, {\n  autoConnect: false\n}); // On connect event handler\n\nsocket.on('disconnect', () => {\n  const store = getStore();\n  store.dispatch(SocketIoActions.disconnectedUser());\n}); // On receive message\n\nsocket.on('message_received', data => {\n  const store = getStore();\n  const chats = store.getState().chats;\n  const i = chats.findIndex(c => c._id === data.chatId);\n\n  if (i < 0) {\n    // This is a new chat created by a peer (need to reload from API)\n    return store.dispatch(ChatActions.fetchUserChats());\n  } // Existing chat add message\n\n\n  store.dispatch(SocketIoActions.inMessage(data));\n}); // Chat server emits this event to confirm the sender that the message is stored in mongo and sent to receiver\n\nsocket.on('message_sent', data => {\n  const store = getStore();\n  store.dispatch(SocketIoActions.outMessageSent(data));\n}); // Chat server emits this event to confirm the sender that the receiver has read the pending messages\n\nsocket.on('messages_confirmed', data => {\n  const store = getStore();\n  store.dispatch(SocketIoActions.outMessagesConfirmed(data));\n}); // Chat server emits to a new user as soon as it connects. Is the list of online users.\n\nsocket.on('all_online', onlineUsers => {\n  const store = getStore();\n  store.dispatch(SocketIoActions.connectedUser());\n  store.dispatch(SocketIoActions.allOnlineUsers(onlineUsers));\n}); // Chat server broadcast this event when someone connect to the server\n\nsocket.on('new_online', login => {\n  const store = getStore();\n  store.dispatch(SocketIoActions.onlineUser(login));\n}); // Chat server broadcast this event when someone disconnect from the server\n\nsocket.on('new_offline', login => {\n  const store = getStore();\n  store.dispatch(SocketIoActions.offlineUser(login));\n}); // On receive status\n\nsocket.on('status', data => console.log(data)); // Default\n\nexport default {\n  // Connect\n  connect: login => {\n    socket.connect();\n    socket.emit('online_user', login);\n  },\n  // Disconnect\n  disconnect: login => {\n    socket.emit('offline_user', login);\n    socket.disconnect();\n  },\n  // Sends message to the server\n  sendMessage: data => {\n    const store = getStore();\n    store.dispatch(SocketIoActions.outMessage(data));\n    socket.emit('message', data);\n  },\n  // Confirms to server that a chat is completely read\n  confirmChatRead: data => {\n    socket.emit('chat_read', data);\n  }\n};","map":{"version":3,"sources":["C:\\Users\\Administrator\\Downloads\\keepcoding-wallaclone-master\\frontend\\src\\socketio\\index.js"],"names":["io","getStore","SocketIoActions","ChatActions","socket","process","env","REACT_APP_CHAT_URL","autoConnect","on","store","dispatch","disconnectedUser","data","chats","getState","i","findIndex","c","_id","chatId","fetchUserChats","inMessage","outMessageSent","outMessagesConfirmed","onlineUsers","connectedUser","allOnlineUsers","login","onlineUser","offlineUser","console","log","connect","emit","disconnect","sendMessage","outMessage","confirmChatRead"],"mappings":"AAAA;AACA,OAAOA,EAAP,MAAe,kBAAf,C,CACA;;AACA,SAASC,QAAT,QAAyB,UAAzB;AACA,SAASC,eAAT,EAA0BC,WAA1B,QAA6C,wBAA7C,C,CAEA;;AACA,OAAO,MAAMC,MAAM,GAAGJ,EAAE,CAACK,OAAO,CAACC,GAAR,CAAYC,kBAAb,EAAiC;AAAEC,EAAAA,WAAW,EAAE;AAAf,CAAjC,CAAjB,C,CAEP;;AACAJ,MAAM,CAACK,EAAP,CAAU,YAAV,EAAwB,MAAM;AAC1B,QAAMC,KAAK,GAAGT,QAAQ,EAAtB;AACAS,EAAAA,KAAK,CAACC,QAAN,CAAeT,eAAe,CAACU,gBAAhB,EAAf;AACH,CAHD,E,CAKA;;AACAR,MAAM,CAACK,EAAP,CAAU,kBAAV,EAA8BI,IAAI,IAAI;AAClC,QAAMH,KAAK,GAAGT,QAAQ,EAAtB;AACA,QAAMa,KAAK,GAAGJ,KAAK,CAACK,QAAN,GAAiBD,KAA/B;AACA,QAAME,CAAC,GAAGF,KAAK,CAACG,SAAN,CAAgBC,CAAC,IAAIA,CAAC,CAACC,GAAF,KAAUN,IAAI,CAACO,MAApC,CAAV;;AACA,MAAIJ,CAAC,GAAG,CAAR,EAAW;AACP;AACA,WAAON,KAAK,CAACC,QAAN,CAAeR,WAAW,CAACkB,cAAZ,EAAf,CAAP;AACH,GAPiC,CAQlC;;;AACAX,EAAAA,KAAK,CAACC,QAAN,CAAeT,eAAe,CAACoB,SAAhB,CAA0BT,IAA1B,CAAf;AACH,CAVD,E,CAYA;;AACAT,MAAM,CAACK,EAAP,CAAU,cAAV,EAA0BI,IAAI,IAAI;AAC9B,QAAMH,KAAK,GAAGT,QAAQ,EAAtB;AACAS,EAAAA,KAAK,CAACC,QAAN,CAAeT,eAAe,CAACqB,cAAhB,CAA+BV,IAA/B,CAAf;AACH,CAHD,E,CAKA;;AACAT,MAAM,CAACK,EAAP,CAAU,oBAAV,EAAgCI,IAAI,IAAI;AACpC,QAAMH,KAAK,GAAGT,QAAQ,EAAtB;AACAS,EAAAA,KAAK,CAACC,QAAN,CAAeT,eAAe,CAACsB,oBAAhB,CAAqCX,IAArC,CAAf;AACH,CAHD,E,CAKA;;AACAT,MAAM,CAACK,EAAP,CAAU,YAAV,EAAwBgB,WAAW,IAAI;AACnC,QAAMf,KAAK,GAAGT,QAAQ,EAAtB;AACAS,EAAAA,KAAK,CAACC,QAAN,CAAeT,eAAe,CAACwB,aAAhB,EAAf;AACAhB,EAAAA,KAAK,CAACC,QAAN,CAAeT,eAAe,CAACyB,cAAhB,CAA+BF,WAA/B,CAAf;AACH,CAJD,E,CAMA;;AACArB,MAAM,CAACK,EAAP,CAAU,YAAV,EAAwBmB,KAAK,IAAI;AAC7B,QAAMlB,KAAK,GAAGT,QAAQ,EAAtB;AACAS,EAAAA,KAAK,CAACC,QAAN,CAAeT,eAAe,CAAC2B,UAAhB,CAA2BD,KAA3B,CAAf;AACH,CAHD,E,CAKA;;AACAxB,MAAM,CAACK,EAAP,CAAU,aAAV,EAAyBmB,KAAK,IAAI;AAC9B,QAAMlB,KAAK,GAAGT,QAAQ,EAAtB;AACAS,EAAAA,KAAK,CAACC,QAAN,CAAeT,eAAe,CAAC4B,WAAhB,CAA4BF,KAA5B,CAAf;AACH,CAHD,E,CAKA;;AACAxB,MAAM,CAACK,EAAP,CAAU,QAAV,EAAoBI,IAAI,IAAIkB,OAAO,CAACC,GAAR,CAAYnB,IAAZ,CAA5B,E,CAEA;;AACA,eAAe;AACX;AACAoB,EAAAA,OAAO,EAAEL,KAAK,IAAI;AACdxB,IAAAA,MAAM,CAAC6B,OAAP;AACA7B,IAAAA,MAAM,CAAC8B,IAAP,CAAY,aAAZ,EAA2BN,KAA3B;AACH,GALU;AAMX;AACAO,EAAAA,UAAU,EAAEP,KAAK,IAAI;AACjBxB,IAAAA,MAAM,CAAC8B,IAAP,CAAY,cAAZ,EAA4BN,KAA5B;AACAxB,IAAAA,MAAM,CAAC+B,UAAP;AACH,GAVU;AAWX;AACAC,EAAAA,WAAW,EAAEvB,IAAI,IAAI;AACjB,UAAMH,KAAK,GAAGT,QAAQ,EAAtB;AACAS,IAAAA,KAAK,CAACC,QAAN,CAAeT,eAAe,CAACmC,UAAhB,CAA2BxB,IAA3B,CAAf;AACAT,IAAAA,MAAM,CAAC8B,IAAP,CAAY,SAAZ,EAAuBrB,IAAvB;AACH,GAhBU;AAiBX;AACAyB,EAAAA,eAAe,EAAEzB,IAAI,IAAI;AACrBT,IAAAA,MAAM,CAAC8B,IAAP,CAAY,WAAZ,EAAyBrB,IAAzB;AACH;AApBU,CAAf","sourcesContent":["// Node\nimport io from 'socket.io-client';\n// Own modules\nimport { getStore } from '../store';\nimport { SocketIoActions, ChatActions } from '../store/GlobalActions';\n\n// Create socket\nexport const socket = io(process.env.REACT_APP_CHAT_URL, { autoConnect: false });\n\n// On connect event handler\nsocket.on('disconnect', () => {\n    const store = getStore();\n    store.dispatch(SocketIoActions.disconnectedUser());\n});\n\n// On receive message\nsocket.on('message_received', data => {\n    const store = getStore();\n    const chats = store.getState().chats;\n    const i = chats.findIndex(c => c._id === data.chatId );\n    if (i < 0) {\n        // This is a new chat created by a peer (need to reload from API)\n        return store.dispatch(ChatActions.fetchUserChats());\n    }\n    // Existing chat add message\n    store.dispatch(SocketIoActions.inMessage(data));\n});\n\n// Chat server emits this event to confirm the sender that the message is stored in mongo and sent to receiver\nsocket.on('message_sent', data => {\n    const store = getStore();\n    store.dispatch(SocketIoActions.outMessageSent(data));\n});\n\n// Chat server emits this event to confirm the sender that the receiver has read the pending messages\nsocket.on('messages_confirmed', data => {\n    const store = getStore();\n    store.dispatch(SocketIoActions.outMessagesConfirmed(data));\n});\n\n// Chat server emits to a new user as soon as it connects. Is the list of online users.\nsocket.on('all_online', onlineUsers => {\n    const store = getStore();\n    store.dispatch(SocketIoActions.connectedUser());\n    store.dispatch(SocketIoActions.allOnlineUsers(onlineUsers));\n});\n\n// Chat server broadcast this event when someone connect to the server\nsocket.on('new_online', login => {\n    const store = getStore();\n    store.dispatch(SocketIoActions.onlineUser(login));\n});\n\n// Chat server broadcast this event when someone disconnect from the server\nsocket.on('new_offline', login => {\n    const store = getStore();\n    store.dispatch(SocketIoActions.offlineUser(login));\n});\n\n// On receive status\nsocket.on('status', data => console.log(data));\n\n// Default\nexport default {\n    // Connect\n    connect: login => {\n        socket.connect();\n        socket.emit('online_user', login); \n    },\n    // Disconnect\n    disconnect: login => {\n        socket.emit('offline_user', login); \n        socket.disconnect();\n    },\n    // Sends message to the server\n    sendMessage: data => {\n        const store = getStore();\n        store.dispatch(SocketIoActions.outMessage(data));\n        socket.emit('message', data);\n    },\n    // Confirms to server that a chat is completely read\n    confirmChatRead: data => {\n        socket.emit('chat_read', data);\n    }\n}"]},"metadata":{},"sourceType":"module"}