{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _Slide = require('@material-ui/core/Slide');\n\nvar _Slide2 = _interopRequireDefault(_Slide);\n\nvar _SnackbarContext = require('./SnackbarContext');\n\nvar _SnackbarContext2 = _interopRequireDefault(_SnackbarContext);\n\nvar _constants = require('./utils/constants');\n\nvar _SnackbarItem = require('./SnackbarItem');\n\nvar _SnackbarItem2 = _interopRequireDefault(_SnackbarItem);\n\nvar _SnackbarContainer = require('./SnackbarContainer');\n\nvar _SnackbarContainer2 = _interopRequireDefault(_SnackbarContainer);\n\nvar _warning = require('./utils/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Omit SnackbarContainer class keys that are not needed for SnakcbarItem\n */\n\n\nvar getClasses = function getClasses(classes) {\n  return Object.keys(classes).filter(function (key) {\n    return !_constants.allClasses.container[key];\n  }).reduce(function (obj, key) {\n    return _extends({}, obj, _defineProperty({}, key, classes[key]));\n  }, {});\n};\n\nvar SnackbarProvider = function (_Component) {\n  _inherits(SnackbarProvider, _Component);\n\n  function SnackbarProvider(props) {\n    _classCallCheck(this, SnackbarProvider);\n\n    var _this = _possibleConstructorReturn(this, (SnackbarProvider.__proto__ || Object.getPrototypeOf(SnackbarProvider)).call(this, props));\n\n    _this.enqueueSnackbar = function (message) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var key = _ref.key,\n          preventDuplicate = _ref.preventDuplicate,\n          options = _objectWithoutProperties(_ref, ['key', 'preventDuplicate']);\n\n      var userSpecifiedKey = key || key === 0;\n      var id = userSpecifiedKey ? key : new Date().getTime() + Math.random();\n\n      var snack = _extends({\n        key: id\n      }, options, {\n        message: message,\n        open: true,\n        entered: false,\n        requestClose: false,\n        anchorOrigin: options.anchorOrigin || _this.props.anchorOrigin\n      });\n\n      if (options.persist) {\n        snack.autoHideDuration = undefined;\n      }\n\n      _this.setState(function (state) {\n        if (preventDuplicate === undefined && _this.props.preventDuplicate || preventDuplicate) {\n          var compareFunction = function compareFunction(item) {\n            return userSpecifiedKey ? item.key === key : item.message === message;\n          };\n\n          var inQueue = state.queue.findIndex(compareFunction) > -1;\n          var inView = state.snacks.findIndex(compareFunction) > -1;\n\n          if (inQueue || inView) {\n            return state;\n          }\n        }\n\n        return _this.handleDisplaySnack(_extends({}, state, {\n          queue: [].concat(_toConsumableArray(state.queue), [snack])\n        }));\n      });\n\n      return id;\n    };\n\n    _this.handleDisplaySnack = function (state) {\n      var snacks = state.snacks;\n\n      if (snacks.length >= _this.props.maxSnack) {\n        return _this.handleDismissOldest(state);\n      }\n\n      return _this.processQueue(state);\n    };\n\n    _this.processQueue = function (state) {\n      var queue = state.queue,\n          snacks = state.snacks;\n\n      if (queue.length > 0) {\n        return _extends({}, state, {\n          snacks: [].concat(_toConsumableArray(snacks), [queue[0]]),\n          queue: queue.slice(1, queue.length)\n        });\n      }\n\n      return state;\n    };\n\n    _this.handleDismissOldest = function (state) {\n      if (state.snacks.some(function (item) {\n        return !item.open || item.requestClose;\n      })) {\n        return state;\n      }\n\n      var popped = false;\n      var ignore = false;\n      var persistentCount = state.snacks.reduce(function (acc, current) {\n        return acc + (current.open && current.persist ? 1 : 0);\n      }, 0);\n\n      if (persistentCount === _this.props.maxSnack) {\n        (0, _warning2.default)(_constants.MESSAGES.NO_PERSIST_ALL);\n        ignore = true;\n      }\n\n      var snacks = state.snacks.map(function (item) {\n        if (!popped && (!item.persist || ignore)) {\n          popped = true;\n\n          if (!item.entered) {\n            return _extends({}, item, {\n              requestClose: true\n            });\n          }\n\n          if (item.onClose) item.onClose(null, _constants.REASONS.MAXSNACK, item.key);\n          if (_this.props.onClose) _this.props.onClose(null, _constants.REASONS.MAXSNACK, item.key);\n          return _extends({}, item, {\n            open: false\n          });\n        }\n\n        return _extends({}, item);\n      });\n      return _extends({}, state, {\n        snacks: snacks\n      });\n    };\n\n    _this.handleEnteredSnack = function (node, isAppearing, key) {\n      if (_this.props.onEntered) {\n        _this.props.onEntered(node, isAppearing, key);\n      }\n\n      _this.setState(function (_ref2) {\n        var snacks = _ref2.snacks;\n        return {\n          snacks: snacks.map(function (item) {\n            return item.key === key ? _extends({}, item, {\n              entered: true\n            }) : _extends({}, item);\n          })\n        };\n      });\n    };\n\n    _this.handleCloseSnack = function (event, reason, key) {\n      if (_this.props.onClose) {\n        _this.props.onClose(event, reason, key);\n      }\n\n      if (reason === _constants.REASONS.CLICKAWAY) return;\n      var shouldCloseAll = key === undefined;\n\n      _this.setState(function (_ref3) {\n        var snacks = _ref3.snacks,\n            queue = _ref3.queue;\n        return {\n          snacks: snacks.map(function (item) {\n            if (!shouldCloseAll && item.key !== key) {\n              return _extends({}, item);\n            }\n\n            return item.entered ? _extends({}, item, {\n              open: false\n            }) : _extends({}, item, {\n              requestClose: true\n            });\n          }),\n          queue: queue.filter(function (item) {\n            return item.key !== key;\n          }) // eslint-disable-line react/no-unused-state\n\n        };\n      });\n    };\n\n    _this.closeSnackbar = function (key) {\n      _this.handleCloseSnack(null, null, key);\n    };\n\n    _this.handleExitedSnack = function (event, key) {\n      _this.setState(function (state) {\n        var newState = _this.processQueue(_extends({}, state, {\n          snacks: state.snacks.filter(function (item) {\n            return item.key !== key;\n          })\n        }));\n\n        if (newState.queue.length === 0) {\n          return newState;\n        }\n\n        return _this.handleDismissOldest(newState);\n      });\n\n      if (_this.props.onExited) {\n        _this.props.onExited(event, key);\n      }\n    };\n\n    _this.state = {\n      snacks: [],\n      queue: [],\n      // eslint-disable-line react/no-unused-state\n      contextValue: {\n        enqueueSnackbar: _this.enqueueSnackbar,\n        closeSnackbar: _this.closeSnackbar\n      }\n    };\n    return _this;\n  }\n  /**\n   * Adds a new snackbar to the queue to be presented.\n   * @param {string} message - text of the notification\n   * @param {object} options - additional options for the snackbar we want to enqueue.\n   * We can pass Material-ui Snackbar props for individual customisation.\n   * @param {string} options.key\n   * @param {string} options.variant - type of the snackbar. default value is 'default'.\n   * can be: (default, success, error, warning, info)\n   * @param {bool} options.persist\n   * @param {bool} options.preventDuplicate\n   * @returns generated or user defined key referencing the new snackbar or null\n   */\n\n  /**\n   * Reducer: Display snack if there's space for it. Otherwise, immediately\n   * begin dismissing the oldest message to start showing the new one.\n   */\n\n  /**\n   * Reducer: Display items (notifications) in the queue if there's space for them.\n   */\n\n  /**\n   * Reducer: Hide oldest snackbar on the screen because there exists a new one which we have to display.\n   * (ignoring the one with 'persist' flag. i.e. explicitly told by user not to get dismissed).\n   *\n   * Note 1: If there is already a message leaving the screen, no new messages are dismissed.\n   * Note 2: If the oldest message has not yet entered the screen, only a request to close the\n   *         snackbar is made. Once it entered the screen, it will be immediately dismissed.\n   */\n\n  /**\n   * Set the entered state of the snackbar with the given key.\n   */\n\n  /**\n   * Hide a snackbar after its timeout.\n   * @param {object} event - The event source of the callback\n   * @param {string} reason - can be timeout, clickaway\n   * @param {number} key - id of the snackbar we want to hide\n   */\n\n  /**\n   * Close snackbar with the given key\n   * @param {number} key - id of the snackbar we want to hide\n   */\n\n  /**\n   * When we set open attribute of a snackbar to false (i.e. after we hide a snackbar),\n   * it leaves the screen and immediately after leaving animation is done, this method\n   * gets called. We remove the hidden snackbar from state and then display notifications\n   * waiting in the queue (if any). If after this process the queue is not empty, the\n   * oldest message is dismissed.\n   * @param {number} key - id of the snackbar we want to remove\n   * @param {object} event - The event source of the callback\n   */\n\n\n  _createClass(SnackbarProvider, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          classes = _props.classes,\n          children = _props.children,\n          maxSnack = _props.maxSnack,\n          dense = _props.dense,\n          domRoot = _props.domRoot,\n          props = _objectWithoutProperties(_props, ['classes', 'children', 'maxSnack', 'dense', 'domRoot']);\n\n      var contextValue = this.state.contextValue;\n      var categ = this.state.snacks.reduce(function (acc, current) {\n        var category = (0, _constants.originKeyExtractor)(current.anchorOrigin);\n        var existingOfCategory = acc[category] || [];\n        return _extends({}, acc, _defineProperty({}, category, [].concat(_toConsumableArray(existingOfCategory), [current])));\n      }, {});\n      var iconVariant = Object.assign(_extends({}, _constants.defaultIconVariant), _extends({}, this.props.iconVariant));\n      var snackbars = Object.entries(categ).map(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            origin = _ref5[0],\n            snacks = _ref5[1];\n\n        return _react2.default.createElement(_SnackbarContainer2.default, {\n          key: origin,\n          dense: dense,\n          anchorOrigin: snacks[0].anchorOrigin,\n          className: classes['containerAnchorOrigin' + origin]\n        }, snacks.map(function (snack) {\n          return _react2.default.createElement(_SnackbarItem2.default, _extends({}, props, {\n            key: snack.key,\n            dense: dense,\n            snack: snack,\n            iconVariant: iconVariant,\n            classes: getClasses(classes),\n            onClose: _this2.handleCloseSnack,\n            onExited: _this2.handleExitedSnack,\n            onEntered: _this2.handleEnteredSnack\n          }));\n        }));\n      });\n      return _react2.default.createElement(_SnackbarContext2.default.Provider, {\n        value: contextValue\n      }, children, domRoot ? (0, _reactDom.createPortal)(snackbars, domRoot) : snackbars);\n    }\n  }]);\n\n  return SnackbarProvider;\n}(_react.Component); // polyfill for Node\n\n\nvar Element = typeof Element === 'undefined' ? function () {} : Element;\nprocess.env.NODE_ENV !== \"production\" ? SnackbarProvider.propTypes = {\n  /**\n   * Most of the time, this is your App. every component from this point onward\n   * will be able to show snackbars.\n   */\n  children: _propTypes2.default.node.isRequired,\n\n  /**\n   * Override or extend the styles applied to the container component or Snackbars.\n   */\n  classes: _propTypes2.default.object,\n\n  /**\n   * Maximum snackbars that can be stacked on top of one another.\n   */\n  maxSnack: _propTypes2.default.number,\n\n  /**\n   * Denser margins for snackbars. Recommended to be used on mobile devices\n   */\n  dense: _propTypes2.default.bool,\n\n  /**\n   * Ignores displaying multiple snackbars with the same `message`\n   */\n  preventDuplicate: _propTypes2.default.bool,\n\n  /**\n   * Hides iconVariant if set to `true`.\n   */\n  hideIconVariant: _propTypes2.default.bool,\n\n  /**\n   * Little icon that is displayed at left corner of a snackbar.\n   */\n  iconVariant: _propTypes2.default.shape({\n    /**\n     * Icon displayed when variant of a snackbar is set to `success`.\n     */\n    success: _propTypes2.default.any,\n\n    /**\n     * Icon displayed when variant of a snackbar is set to `warning`.\n     */\n    warning: _propTypes2.default.any,\n\n    /**\n     * Icon displayed when variant of a snackbar is set to `error`.\n     */\n    error: _propTypes2.default.any,\n\n    /**\n     * Icon displayed when variant of a snackbar is set to `info`.\n     */\n    info: _propTypes2.default.any\n  }),\n\n  /**\n   * Callback used for getting action(s). actions are mostly buttons displayed in Snackbar.\n   * @param {string|number} key key of a snackbar\n   */\n  action: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.object]),\n\n  /**\n   * Replace the snackbar. Callback used for displaying entirely customized snackbar.\n   * @param {string|number} key key of a snackbar\n   */\n  content: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.object]),\n\n  /**\n   * The anchor of the `Snackbar`.\n   */\n  anchorOrigin: _propTypes2.default.shape({\n    horizontal: _propTypes2.default.oneOf(['left', 'center', 'right']).isRequired,\n    vertical: _propTypes2.default.oneOf(['top', 'bottom']).isRequired\n  }),\n\n  /**\n   * The number of milliseconds to wait before automatically calling the\n   * `onClose` function. `onClose` should then set the state of the `open`\n   * prop to hide the Snackbar. This behavior is disabled by default with\n   * the `null` value.\n   */\n  autoHideDuration: _propTypes2.default.number,\n\n  /**\n   * If `true`, the `autoHideDuration` timer will expire even if the window is not focused.\n   */\n  disableWindowBlurListener: _propTypes2.default.bool,\n\n  /**\n   * Callback fired when the component requests to be closed.\n   * The `reason` parameter can optionally be used to control the response to `onClose`,\n   * for example ignoring `clickaway`.\n   *\n   * @param {object} event The event source of the callback\n   * @param {string} reason Can be:`\"timeout\"` (`autoHideDuration` expired) or: `\"clickaway\"`\n   *  or: `\"maxsnack\"` (snackbar is closed because `maxSnack` has reached.)\n   * @param {string|number} key key of a Snackbar\n   */\n  onClose: _propTypes2.default.func,\n\n  /**\n   * Callback fired before the transition is entering.\n   */\n  onEnter: _propTypes2.default.func,\n\n  /**\n   * Callback fired when the transition has entered.\n   */\n  onEntered: _propTypes2.default.func,\n\n  /**\n   * Callback fired when the transition is entering.\n   */\n  onEntering: _propTypes2.default.func,\n\n  /**\n   * Callback fired before the transition is exiting.\n   */\n  onExit: _propTypes2.default.func,\n\n  /**\n   * Callback fired when the transition has exited.\n   */\n  onExited: _propTypes2.default.func,\n\n  /**\n   * Callback fired when the transition is exiting.\n   */\n  onExiting: _propTypes2.default.func,\n\n  /**\n   * The number of milliseconds to wait before dismissing after user interaction.\n   * If `autoHideDuration` property isn't specified, it does nothing.\n   * If `autoHideDuration` property is specified but `resumeHideDuration` isn't,\n   * we default to `autoHideDuration / 2` ms.\n   */\n  resumeHideDuration: _propTypes2.default.number,\n\n  /**\n   * The component used for the transition.\n   */\n  TransitionComponent: _propTypes2.default.elementType,\n\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   */\n  transitionDuration: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.shape({\n    enter: _propTypes2.default.number,\n    exit: _propTypes2.default.number\n  })]),\n\n  /**\n   * Valid and exist HTML Node element, used to target `ReactDOM.createPortal`\n   */\n  domRoot: _propTypes2.default.instanceOf(Element)\n} : void 0;\nSnackbarProvider.defaultProps = {\n  maxSnack: 3,\n  dense: false,\n  preventDuplicate: false,\n  hideIconVariant: false,\n  classes: {},\n  iconVariant: {},\n  anchorOrigin: {\n    vertical: 'bottom',\n    horizontal: 'left'\n  },\n  autoHideDuration: 5000,\n  TransitionComponent: _Slide2.default\n};\nexports.default = SnackbarProvider;","map":null,"metadata":{},"sourceType":"script"}